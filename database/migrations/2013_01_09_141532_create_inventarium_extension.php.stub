<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;

return new class extends Migration {
  public string $schema = 'inventarium';

  /**
   * Run the migrations.
   *
   * @return void
   */
  public function up()
  {
    DB::transaction(function () {
      DB::statement('CREATE SCHEMA IF NOT EXISTS ' . $this->schema);

      // Create utility functions
      Schema::createFunctionOrReplace(
        name: $this->schema . '.get_primary_key_name',
        parameters: [
          'p_table_schema' => 'text',
          'p_table_name' => 'text',
        ],
        return: 'text',
        body: sprintf(
          <<<PLPGSQL
  DECLARE
    primary_key_name text;
  BEGIN
    EXECUTE format(
        '
          SELECT c.column_name
            FROM information_schema.table_constraints tc 
            JOIN information_schema.constraint_column_usage AS ccu 
              USING (constraint_schema, constraint_name) 
            JOIN information_schema.columns AS c 
              ON 
                  c.table_schema = tc.constraint_schema
                AND 
                  tc.table_name = c.table_name 
                AND 
                  ccu.column_name = c.column_name
            WHERE 
                constraint_type = ''PRIMARY KEY''
              AND 
                tc.table_schema = %%L
              AND 
                tc.table_name = %%L
        ',
        p_table_schema,
        p_table_name
      ) 
      INTO primary_key_name;

    RETURN primary_key_name;
  END;
PLPGSQL
        ),
        language: 'PLPGSQL'
      );

      Schema::createFunctionOrReplace(
        name: $this->schema . '.create',
        parameters: [
          'p_table_schema' => 'text',
          'p_table_name' => 'text',
          'p_source_name' => 'text',
          'p_weight' => "char DEFAULT 'A'",
          'p_language_name' => "text DEFAULT NULL",
          'p_search_config' => "text DEFAULT NULL",
        ],
        return: 'void',
        body: sprintf(
          <<<PLPGSQL
  BEGIN
    INSERT INTO %1\$s.definitions 
        (table_schema, table_name, target_name, group_by, source_name) 
      VALUES 
        (p_table_schema, p_table_name, p_target_name, p_group_by, p_source_name);
  END;
PLPGSQL
          ,
          $this->schema
        ),
        language: 'PLPGSQL'
      );

      // Create tables
      Schema::create($this->schema . '.definitions', function (
        Blueprint $table
      ) {
        $table->id()->generatedAs();

        $table->text('table_schema');
        $table->text('table_name');
        $table->text('source_name');
        $table->char('weight', 1)->default('A');
        $table->text('language_name')->nullable();
        $table->text('search_config')->default('simple');
        $table->text('primary_key_name');
      });

      Schema::create($this->schema . '.searchables', function (Blueprint $table) {
        $table->id()->generatedAs();

        $table->unsignedBigInteger('definition_id');
        $table
          ->foreign('definition_id')
          ->references('id')
          ->on($this->schema . '.definitions')
          ->cascadeOnDelete();

        $table->text('primary_key');

        $table->text('trigrams');

        $table->timestampTz('created_at')->default(DB::raw('NOW()'));
        $table->timestampTz('updated_at')->default(DB::raw('NOW()'));

        $table->index(['definition_id', 'primary_key']);
      });

      DB::statement(
        sprintf(<<<SQL
            ALTER TABLE %1\$s.searchables
              ADD COLUMN vectors tsvector;
          SQL, 
          $this->schema
        )
      );

      Schema::create($this->schema . '.languages', function (Blueprint $table) {
        $table->char('code', 2)->unique();
      });

      DB::statement(
        sprintf(<<<SQL
            ALTER TABLE %1\$s.languages
              ADD COLUMN search_config regconfig;
          SQL, 
          $this->schema
        )
      );

      // Create trigger functions
      Schema::createFunctionOrReplace(
        name: $this->schema . '.definitions__before',
        parameters: [],
        return: 'trigger',
        body: sprintf(
          <<<PLPGSQL
  BEGIN
    -- Prevent updates
    IF TG_OP = 'UPDATE' THEN
      NEW.table_schema = OLD.table_schema;
      NEW.table_name = OLD.table_name;
      NEW.source_name = OLD.source_name;
      NEW.weight = OLD.weight;
      NEW.language_name = OLD.language_name;
      NEW.search_config = OLD.search_config;
    END IF;

    -- Determine primary key name automatically
    NEW.primary_key_name = %1\$s.get_primary_key_name(NEW.table_schema, NEW.table_name);
    
    IF NEW.primary_key_name IS NULL THEN
      RAISE EXCEPTION 'Table %%.%% does not have a primary key.', NEW.table_schema, NEW.table_name;
    END IF;

    RETURN NEW;
  END;
PLPGSQL
          ,
          $this->schema
        ),
        language: 'PLPGSQL'
      );

      Schema::createFunctionOrReplace(
        name: $this->schema . '.definitions__after',
        parameters: [],
        return: 'trigger',
        body: sprintf(
          <<<PLPGSQL
DECLARE
  trigger_name text;
  index_name text;
  index_column_names text;
  id int;
BEGIN
  -- Log
  RAISE DEBUG '
    %1\$s.definition__after: start (
      TG_NAME=%%, 
      TG_OP=%%, 
      TG_TABLE_NAME=%%, 
      OLD=%%, 
      NEW=%%, 
      TG_ARGV=%%
    )', 
    TG_NAME, 
    TG_OP, 
    TG_TABLE_NAME, 
    OLD::text, 
    NEW::text, 
    TG_ARGV::text;

  -- Determine names
  id = CASE WHEN TG_OP = 'DELETE' THEN OLD.id ELSE NEW.id END;
  trigger_name = format('9999_inventarium_%%s__before', id);
  index_name = format('%%s_inventarium', NEW.table_name, id);

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;

  IF TG_OP = 'INSERT' THEN
    -- Create columns
    EXECUTE format(
      'ALTER TABLE %%I.%%I ADD COLUMN IF NOT EXISTS %%I tsvector NULLABLE', 
      NEW.table_schema,
      NEW.table_name,
      'vectors'
    );
    EXECUTE format(
      'ALTER TABLE %%I.%%I ADD COLUMN IF NOT EXISTS %%I text NULLABLE', 
      NEW.table_schema,
      NEW.table_name,
      'trigrams'
    );

    -- Create trigger
    EXECUTE format('DROP TRIGGER IF EXISTS %%I ON %%I.%%I', trigger_name, NEW.table_schema, NEW.table_name);
    EXECUTE format('
      CREATE TRIGGER %%I
        BEFORE INSERT OR UPDATE OR DELETE
        ON %%I.%%I
        FOR EACH ROW 
        EXECUTE FUNCTION %1\$s.inventarium__before()
      ', trigger_name, NEW.table_schema, NEW.table_name);
  END IF;

  -- Create index
  IF TG_OP = 'INSERT' THEN
    EXECUTE format('
      CREATE INDEX IF NOT EXISTS %%I
        ON %%I.%%I USING GIN (%%I)
      ', index_name, NEW.table_schema, NEW.table_name, 'vectors');

    EXECUTE format('
      CREATE INDEX IF NOT EXISTS %%I
        ON %%I.%%I USING GIN (%%I gin_trgm_ops)
      ', index_name, NEW.table_schema, NEW.table_name, 'trigrams');
  END IF;  

  RETURN NEW;
END;
PLPGSQL
          ,
          $this->schema
        ),
        language: 'PLPGSQL'
      );

      Schema::createFunctionOrReplace(
        name: $this->schema . '.inventarium__before',
        parameters: [],
        return: 'trigger',
        body: sprintf(
          <<<PLPGSQL
DECLARE
  definition %1\$s.definitions%%rowtype;

  vectors tsvector;
  trigrams text;
  source_value text;
  language_value text;
  search_config regconfig DEFAULT 'simple';
BEGIN
  -- Log
  RAISE DEBUG '
    %1\$s.inventarium__before: start (
      TG_NAME=%%, 
      TG_OP=%%, 
      TG_TABLE_SCHEMA=%%, 
      TG_TABLE_NAME=%%, 
      OLD=%%, 
      NEW=%%, 
      TG_ARGV=%%
    )', 
    TG_NAME, 
    TG_OP, 
    TG_TABLE_SCHEMA,
    TG_TABLE_NAME, 
    OLD::text, 
    NEW::text, 
    TG_ARGV::text;

  -- Nothing to do yet
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;

  -- Go through all definitions and create vectors and trigrams
  vectors := to_tsvector('simple', '');
  FOR definition IN SELECT * FROM %1\$s.definitions 
    WHERE
        table_schema = TG_TABLE_SCHEMA
      AND
        table_name = TG_TABLE_NAME
  LOOP
    EXECUTE format(
      'SELECT %%s FROM (SELECT $1.*) record;',
      source_name, 
      USING NEW 
      INTO source_value;
    EXECUTE format(
      'SELECT %%s FROM (SELECT $1.*) record;',
      language_name, 
      USING NEW 
      INTO language_value;

    -- Get search config from language table
    IF p_language_code IS NOT NULL AND p_language_code != '' THEN
      SELECT 
        languages.search_config 
          FROM
            languages
          WHERE
            code = language_value
          LIMIT 1
          INTO search_config;
    END IF;

    -- Fallback to default search config
    IF search_config IS NULL THEN
      search_config := definition.search_Config;
    END IF;
      
    vectors = vectors @@ to_tsvector(
      search_config,
      source_value
    );
  END LOOP;

  -- Assign computed vectors and trigrams
  NEW.vectors = vectors;
  NEW.trigrams = show_trgm(array_to_string(tsvector_to_array(p_input), ' '));

  RETURN NEW;
END;
PLPGSQL
          ,
          $this->schema
        ),
        language: 'PLPGSQL'
      );

      // Create triggers initially
      DB::statement(
        sprintf(
          <<<PLPGSQL
CREATE OR REPLACE TRIGGER "100_prepare_before"
  BEFORE INSERT OR UPDATE OR DELETE ON %1\$s.definitions
  FOR EACH ROW 
  EXECUTE FUNCTION %1\$s.definitions__before();
PLPGSQL
          ,
          $this->schema
        )
      );

      DB::statement(
        sprintf(
          <<<PLPGSQL
  CREATE OR REPLACE TRIGGER "100_create_artifacts_after"
    AFTER INSERT OR UPDATE OR DELETE ON %1\$s.definitions
    FOR EACH ROW 
    EXECUTE FUNCTION %1\$s.definitions__after();
PLPGSQL
          ,
          $this->schema
        )
      );

      // Grant permissions
      $user = DB::select('SELECT current_user;')[0]->current_user;

      DB::statement(
        sprintf(
          <<<PLPGSQL
  GRANT USAGE ON SCHEMA %1\$s TO %2\$s;
PLPGSQL
          ,
          $this->schema,
          $user
        )
      );
      DB::statement(
        sprintf(
          <<<PLPGSQL
  GRANT SELECT ON TABLE %1\$s.definitions TO %2\$s;
PLPGSQL
          ,
          $this->schema,
          $user
        )
      );
    });
  }

  /**
   * Reverse the migrations.
   *
   * @return void
   */
  public function down()
  {
    DB::statement('DROP SCHEMA IF EXISTS ' . $this->schema . ' CASCADE;');
  }
};
